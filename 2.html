<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .products {
      overflow: hidden;
      margin-top: 40px;
    }

    .product {
      float: left;
      margin-right: 20px;
    }
  </style>
</head>
<body>
<header>
  <button class="menuButton" data-type="phones">Показать смартфоны</button>
  <button class="menuButton" data-type="tablets">Показать планшеты</button>
  <button class="menuButton" data-type="tv">Показать телевизоры</button>
</header>

<div class="products"></div>

<script>
  /*
  1. Программист Паша уволился с работы и не закончил задачу.
  Задача состояла в том, чтобы при клике на какую-либо кнопку в теге header
  выводить продукты в div с классом products.
  Продукты, которые надо вывести, валидны и прописаны в объекте products.
  Однако, Паша явно сделал много ошибок в других кусках кода, вам необходимо
  исправить все ошибки и внимательно проверить чтоб код работал правильно и
  ничего лишнего не выводилось в div с классом products.
  */

  class Product {
    constructor(id, name, price, imageUrl) {
      this.id = id;
      this.name = name;
      this.price = price;
      this.imageUrl = imageUrl;
    }

    /**
     * @returns {string} html-разметка для товара
     */
    getProductMarkup() {
      
      /*//было ${name} ${imageUrl} ${id}
      надо ${this.name} ${this.imageUrl} ${this.id}
      поскольку через this идет привязка к текущему обрабатываемому
      функцией getProductMarkup объекту
      а отдельно переменные name imageUrl price и id созданы не были
      и тогда глобальная переменная name в глобальном объекте window 
      имеет значение пустая строка или ''
      */
      return `
        <div class="product">
            <div>${this.name}</div>
            <img src="${this.imageUrl}" alt="">
            <div>Цена: <span>${this.price}</span> р.</div>
            <a href="https://example.com/producs/${this.id}">Подробнее</a>
        </div>
      `;
    }
  }

  const products = {
    phones: [
      new Product(1, "Смартфон 1", "2533", "https://picsum.photos/seed/1/200"),
      new Product(2, "Смартфон 2", "3123", "https://picsum.photos/seed/2/200"),
      new Product(3, "Смартфон 3", "6123", "https://picsum.photos/seed/3/200"),
    ],
    tablets: [
      new Product(4, "Плашнет 1", "5239", "https://picsum.photos/seed/4/200"),
      new Product(5, "Плашнет 2", "6483", "https://picsum.photos/seed/5/200"),
    ],
    tv: [
      new Product(6, "Телевизор 1", "4314", "https://picsum.photos/seed/6/200"),
      new Product(7, "Телевизор 2", "5412", "https://picsum.photos/seed/7/200"),
      new Product(8, "Телевизор 3", "3577", "https://picsum.photos/seed/8/200"),
      new Product(9, "Телевизор 4", "8714", "https://picsum.photos/seed/9/200"),
    ],
  };
  //было 'products'
  //надо '.products' поскольку это класс, в методе querySelector 
  //перед указанием класса нужна точка '.'
  const productsEl = document.querySelector('.products');
  document.querySelector('header').addEventListener('click', event => {
  /*
  event.currentTarget. Определяет элемент, в котором в данный момент 
  обрабатывается событие, при движении события внутри DOM.
  event.target – это исходный элемент, на котором произошло событие, 
  в процессе всплытия он неизменен
  https://learn.javascript.ru/event-bubbling
  было event.currentTarget
  надо event.target
  
  при применении classList сам класс писать без точки '.'
  было '.menuButton'
  надо 'menuButton'
  
  */
    if (event.target.classList.contains('menuButton')) {
    /*
    map Метод map() создаёт новый массив с результатом вызова
    указанной функции для каждого элемента массива
    let new_array = arr.map(function callback( currentValue[, index[, array]]) {
    // Возвращает элемент для new_array }[, thisArg])
    callback - Функция, вызываемая для каждого элемента массива arr.
    Каждый раз, когда callback выполняется, возвращаемое значение 
    добавляется в new_array
    т.е. все элементы массива будут заменены на те, которые вернет
    callback функция 
    у нас это стрелочная функция 
    product => product.etProductMarkup() которая возвращает
    html разметку для товара, которая и будет элементом массива
    в общем получим массив html разметок по какому то отдельному типу
    продукта .dataset (эти типы:
    data-type="phones" или data-type="tablets" или data-type="tv")
    а .type это непосредственное 
    */
    //было event.currentTarget
    //надо event.target
    /*
    Свойство интерфейса Element innerHTML устанавливает или получает HTML или 
    XML разметку дочерних элементов
    https://developer.mozilla.org/ru/docs/Web/API/Element/innerHTML
    
    Метод join() (с параметром по умолчанию пустая строка '')
    объединяет все элементы массива (или массивоподобного объекта) 
    в строку с заданным разделителем (у нас это пустая строка''), 
    т.е. в нашем случае заменяет из html разметок разделяющие 
    элементы массива символы (у нас это будут запятые) на параметр 
    по умолчанию (пустая строка)
    https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join
    */
    console.dir(products[event.target.dataset]);
    console.dir(products[event.target.dataset.type]);
    productsEl.innerHTML = products[event.target.dataset.type]
      .map(product => product.getProductMarkup()).join('');
      }
  });

</script>
</body>
</html>